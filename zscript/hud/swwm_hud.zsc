// Shared HUD code, to be extended in subclasses

Class MsgLine
{
	String str;
	transient BrokenLines l, ls;
	int tic, type, rep;
	int lastrep;
	int lastsz;

	void UpdateText( int sz = 0 )
	{
		bool mustupdate = (!l||!ls||(lastrep!=rep)||((type==PRINT_LOW)&&(sz!=lastsz)));
		if ( !mustupdate ) return;
		if ( l ) l.Destroy();
		if ( ls ) ls.Destroy();
		lastsz = sz;
		lastrep = rep;
		String nstr = str;
		if ( rep > 1 ) nstr.AppendFormat(" (x%d)",rep);
		let fnt = Font.GetFont('TewiFont');
		l = fnt.BreakLines(nstr,(type==PRINT_LOW)?sz:361);
		if ( type != PRINT_LOW ) ls = fnt.BreakLines(nstr,211);
	}
}

Class KeyGet
{
	Class<Key> got;
	int flashtime;
}

Enum EMiniHUDFontColor
{
	MCR_WHITE,
	MCR_RED,
	MCR_GREEN,
	MCR_BLUE,
	MCR_CYAN,
	MCR_PURPLE,
	MCR_YELLOW,
	MCR_BRASS,
	MCR_SILVER,
	MCR_GOLD,
	MCR_MANA,
	MCR_ELDRITCH,
	MCR_CRIMSON,
	MCR_FLASH,
	MCR_REDFLASH
};

Class SWWMStatusBar : BaseStatusBar abstract
{
	TextureID ChatTex[6], MiniBox, PauseTex, InventoryTex, bgtex, EnemyBTex, EnemyHTex[3];
	Font MiniHUDFont, MiniHUDFontOutline, mSmallFont, mBigFont, mTinyFont;
	int mhudfontcol[15];

	Array<MsgLine> MainQueue, PickupQueue;

	// the event handler, holding all sorts of stuff
	SWWMHandler hnd;

	// shared stuff
	double hs;
	Vector2 ss;
	int margin;
	double FracTic;
	double FrameTime;
	int PrevFrame;
	int chatopen;
	bool camhidden;
	int pausetime;
	Vector2 pausepos, pausedir;
	int PulsePhase;	// for health pulsing

	// shared from renderunderlay, needed for proper interpolation of some things
	Vector3 viewpos, viewrot;
	// projection data cache
	SWWMProjectionData projdata;

	Inventory lastsel;
	Weapon lastwep;
	String ntagstr;
	int ntagtic, ntagcol;

	String midstr;
	int midtic, midtype;
	transient BrokenLines midl;
	int midsz;

	SWWMWeaponTooltip ctip;

	// for flashing some elements in the hud
	Array<KeyGet> keyflash;
	int oldkills, olditems, oldsecrets;
	int oldtkills, oldtitems, oldtsecrets;
	int killflash, itemflash, secretflash;
	int tkillflash, titemflash, tsecretflash;

	double mm_zoom;
	transient ThinkerIterator mi;	// for map markers
	// for interpolation
	double minimapzoom, oldminimapzoom;
	// minimap constants
	const CLIPDIST = 800;		// clip distance for minimap view, with rotation accounted
	const MAPVIEWDIST = 1132;	// maximum distance for something to be considered visible (rounded up CLIPDIST*sqrt(2))
	const HALFMAPSIZE = 40;		// half the size of the minimap draw region (unscaled)

	// minimap colors (thats a lot of 'em)
	int mm_colorset;
	Color mm_backcolor, mm_cdwallcolor, mm_efwallcolor, mm_fdwallcolor, mm_interlevelcolor, mm_intralevelcolor, mm_lockedcolor, mm_notseencolor, mm_portalcolor, mm_secretsectorcolor, mm_secretwallcolor, mm_specialwallcolor, mm_tswallcolor, mm_unexploredsecretcolor, mm_wallcolor, mm_yourcolor;

	// top stuff colors
	int tclabel, tcvalue, tcextra, tccompl, tcsucks;
	String tclabel_s, tcextra_s;

	// hints (mainly for Kirin mod)
	bool bAlwaysDrawInv,		// always draws the inventory box, even if empty
		bAlwaysAboveInv;	// powerups are always drawn above the inventory box, even when shifted to the right
	int AboveInvOffset;		// (Saya mod) additional offset applied to displays over inventory box

	// for combat trackers
	transient ThinkerIterator cti;

	override void FlushNotify()
	{
		if ( level.maptime <= 1 )
		{
			// flush ALL messages
			MainQueue.Clear();
			PickupQueue.Clear();
			return;
		}
		// flush non-chat messages
		for ( int i=0; i<MainQueue.Size(); i++ )
		{
			if ( MainQueue[i].type >= PRINT_CHAT ) continue;
			MainQueue.Delete(i);
			i--;
		}
		// flush nametag
		ntagstr = "";
		ntagtic = 0;
	}

	override bool ProcessMidPrint( Font fnt, String msg, bool bold )
	{
		// hack lol
		if ( msg.Left(15) ~== "swwmwpntooltip." )
		{
			String wname = msg.Mid(15);
			Class<SWWMWeapon> w = wname;
			if ( w )
			{
				let tt = new("SWWMWeaponTooltip").Init(w);
				bool appended = false;
				for ( SWWMWeaponTooltip t=ctip; t; t=t.next )
				{
					if ( t.next ) continue;
					appended = true;
					t.next = tt;
					break;
				}
				if ( !appended )
				{
					ctip = tt;
					AttachMessage(tt,-2910);
				}
			}
			return true;
		}
		else if ( msg.Left(11) ~== "swwmkeyget." )
		{
			String kname = msg.Mid(11);
			Class<Key> k = kname;
			if ( k )
			{
				let kg = new("KeyGet");
				kg.got = k;
				kg.flashtime = gametic+25;
				keyflash.Push(kg);
			}
			return true;
		}
		if ( !fnt || (fnt == smallfont) )
		{
			midstr = msg;
			midtic = level.totaltime;
			midtype = bold?2:0;
			return true;
		}
		if ( (fnt == bigfont) || (fnt == originalbigfont) )
		{
			midstr = msg;
			midtic = level.totaltime;
			midtype = bold?3:1;
			return true;
		}
		return false;
	}

	override bool ProcessNotify( EPrintLevel printlevel, String outline )
	{
		// ignore during intermission
		if ( gamestate != GS_LEVEL ) return false;
		if ( (printlevel < PRINT_LOW) || (printlevel > PRINT_TEAMCHAT) ) return true;	// we couldn't care less about these
		let m = new("MsgLine");
		m.str = outline.Left(outline.Length()-1);	// strip newline
		m.type = printlevel;
		m.tic = level.totaltime;
		m.rep = 1;
		if ( printlevel == PRINT_LOW )
		{
			// check if repeated
			for ( int i=0; i<PickupQueue.Size(); i++ )
			{
				if ( PickupQueue[i].str != m.str ) continue;
				// delete old one and add its repeats
				m.rep += PickupQueue[i].rep;
				PickupQueue.Delete(i);
				break;
			}
			m.UpdateText(int(ss.x*.75));
			PickupQueue.Push(m);
		}
		else
		{
			// check if repeated
			for ( int i=0; i<MainQueue.Size(); i++ )
			{
				if ( MainQueue[i].str != m.str ) continue;
				// delete old one and add its repeats
				m.rep += MainQueue[i].rep;
				MainQueue.Delete(i);
				break;
			}
			m.UpdateText();
			MainQueue.Push(m);
		}
		return true;
	}

	abstract void UpdateInterpolators();

	override void Tick()
	{
		Super.Tick();
		pausetime = gametic;
		// prune old messages
		for ( int i=0; i<PickupQueue.Size(); i++ )
		{
			if ( level.totaltime < (PickupQueue[i].tic+GameTicRate*swwm_pickduration) ) continue;
			PickupQueue.Delete(i);
			i--;
		}
		for ( int i=0; i<MainQueue.Size(); i++ )
		{
			if ( (MainQueue[i].type <= PRINT_HIGH) && (level.totaltime < (MainQueue[i].tic+GameTicRate*swwm_msgduration)) ) continue;
			else if ( (MainQueue[i].type > PRINT_HIGH) && (level.totaltime < (MainQueue[i].tic+GameTicRate*swwm_chatduration)) ) continue;
			MainQueue.Delete(i);
			i--;
		}
		// update interpolators
		UpdateInterpolators();
		if ( CPlayer.ReadyWeapon is 'SWWMWeapon' )
			SWWMWeapon(CPlayer.ReadyWeapon).HudTick();
		double desiredzoom = clamp(mm_zoom,.5,1.);
		if ( (minimapzoom != mm_zoom) || (oldminimapzoom != mm_zoom) )
		{
			oldminimapzoom = minimapzoom;
			double diff = .1*(desiredzoom-minimapzoom);
			minimapzoom += diff;
			if ( abs(minimapzoom-desiredzoom) <= .01 )
				minimapzoom = desiredzoom;
		}
		// part of gross hackery to override nametag display
		if ( CPlayer.inventorytics > 0 )
		{
			if ( CPlayer.mo.InvSel && (CPlayer.mo.InvSel != lastsel) && (displaynametags&1) && (CPlayer == players[consoleplayer]) )
			{
				ntagstr = CPlayer.mo.InvSel.GetTag();
				ntagtic = level.totaltime;
				ntagcol = nametagcolor;
			}
			lastsel = CPlayer.mo.InvSel;
		}
		if ( CPlayer.PendingWeapon && (CPlayer.PendingWeapon != WP_NOCHANGE) && (CPlayer.PendingWeapon != lastwep) )
		{
			if ( (displaynametags&2) && (CPlayer == players[consoleplayer]) )
			{
				ntagstr = CPlayer.PendingWeapon.GetTag();
				ntagtic = level.totaltime;
				ntagcol = nametagcolor;
			}
		}
		lastwep = CPlayer.PendingWeapon;
		// make sure vanilla nametags don't display
		DetachMessageID(0x5745504e);	// WEPN
		DetachMessageID(0x53494e56);	// SINV
		// also try with different endianness, just in case
		DetachMessageID(0x4e504557);	// WEPN
		DetachMessageID(0x564e4953);	// SINV
		// stats flashing
		if ( level.killed_monsters > oldkills )
		{
			oldkills = level.killed_monsters;
			killflash = gametic+25;
		}
		if ( level.found_items > olditems )
		{
			olditems = level.found_items;
			itemflash = gametic+25;
		}
		if ( level.found_secrets > oldsecrets )
		{
			oldsecrets = level.found_secrets;
			secretflash = gametic+25;
		}
		if ( level.total_monsters > oldtkills )
		{
			oldtkills = level.total_monsters;
			tkillflash = gametic+25;
		}
		if ( level.total_items > oldtitems )
		{
			oldtitems = level.total_items;
			titemflash = gametic+25;
		}
		if ( level.total_secrets > oldtsecrets )
		{
			oldtsecrets = level.total_secrets;
			tsecretflash = gametic+25;
		}
		// purge expired key flashes
		for ( int i=0; i<keyflash.Size(); i++ )
		{
			if ( keyflash[i].flashtime >= gametic ) continue;
			keyflash.Delete(i--);
		}
		// low health pulsing
		if ( (CPlayer.health <= 0) || (CPlayer.health > 25) )
		{
			PulsePhase = 0;
			return;
		}
		if ( PulsePhase == 15 )
			S_StartSound("misc/heartbeat",CHAN_BODY,CHANF_UI|CHANF_OVERLAP,(30-CPlayer.health)/50.);
		PulsePhase--;
		if ( (PulsePhase < 0) || (PulsePhase > CPlayer.health*2+25) )
			PulsePhase = CPlayer.health*2+25;
	}

	override void Init()
	{
		Super.Init();
		// scaling is set to 640 pixels wide minimum
		// and height set so it fits up to ultrawide (2.370:1 ~ 2.4:1)
		// ultrawide is honestly an abomination,
		// and these numbers should be proof enough of it
		// none of the commercially available "21:9" screens even have
		// that actual ratio in the first place, what the fuck man
		// they dangle anywhere between 12:4, 43:18 and 64:27
		// fuck ultrawide, seriously
		// get a 16:10 screen instead, it's the best aspect ratio
		SetSize(0,640,266);
		ChatTex[0] = TexMan.CheckForTexture("graphics/HUD/ChatBoxTop.png",TexMan.Type_Any);
		ChatTex[1] = TexMan.CheckForTexture("graphics/HUD/ChatBoxLine.png",TexMan.Type_Any);
		ChatTex[2] = TexMan.CheckForTexture("graphics/HUD/ChatBoxBottom.png",TexMan.Type_Any);
		ChatTex[3] = TexMan.CheckForTexture("graphics/HUD/ChatBoxTop_Smol.png",TexMan.Type_Any);
		ChatTex[4] = TexMan.CheckForTexture("graphics/HUD/ChatBoxLine_Smol.png",TexMan.Type_Any);
		ChatTex[5] = TexMan.CheckForTexture("graphics/HUD/ChatBoxBottom_Smol.png",TexMan.Type_Any);
		InventoryTex = TexMan.CheckForTexture("graphics/HUD/InventoryBox.png",TexMan.Type_Any);
		EnemyBTex = TexMan.CheckForTexture("graphics/HUD/EnemyBox.png",TexMan.Type_Any);
		EnemyHTex[0] = TexMan.CheckForTexture("graphics/HUD/EnemyBar.png",TexMan.Type_Any);
		EnemyHTex[1] = TexMan.CheckForTexture("graphics/HUD/EnemyBarInvul.png",TexMan.Type_Any);
		EnemyHTex[2] = TexMan.CheckForTexture("graphics/HUD/EnemyBarLag.png",TexMan.Type_Any);
		MiniBox = TexMan.CheckForTexture("graphics/HUD/MinimapBox.png",TexMan.Type_Any);
		PauseTex = TexMan.CheckForTexture("graphics/"..SWWMMODPREFIX.."pause.png",TexMan.Type_Any);
		bgtex = TexMan.CheckForTexture("graphics/tempbg.png",TexMan.Type_Any);
		mm_zoom = minimapzoom = oldminimapzoom = 1.;
		MiniHudFont = Font.GetFont("MiniHUD");
		MiniHudFontOutline = Font.GetFont("MiniHUDOutline");
		mSmallFont = Font.GetFont('TewiFont');
		mBigFont = Font.GetFont('TewiFontOutline');
		mTinyFont = Font.GetFont('MiniwiFont');
		mhudfontcol[MCR_WHITE] = Font.FindFontColor("MiniWhite");
		mhudfontcol[MCR_RED] = Font.FindFontColor("MiniRed");
		mhudfontcol[MCR_GREEN] = Font.FindFontColor("MiniGreen");
		mhudfontcol[MCR_BLUE] = Font.FindFontColor("MiniBlue");
		mhudfontcol[MCR_CYAN] = Font.FindFontColor("MiniCyan");
		mhudfontcol[MCR_PURPLE] = Font.FindFontColor("MiniPurple");
		mhudfontcol[MCR_YELLOW] = Font.FindFontColor("MiniYellow");
		mhudfontcol[MCR_BRASS] = Font.FindFontColor("MiniBrass");
		mhudfontcol[MCR_SILVER] = Font.FindFontColor("MiniSilver");
		mhudfontcol[MCR_GOLD] = Font.FindFontColor("MiniGold");
		mhudfontcol[MCR_MANA] = Font.FindFontColor("MiniMana");
		mhudfontcol[MCR_ELDRITCH] = Font.FindFontColor("MiniEldritch");
		mhudfontcol[MCR_CRIMSON] = Font.FindFontColor("MiniCrimson");
		mhudfontcol[MCR_FLASH] = Font.FindFontColor("MiniFlash");
		mhudfontcol[MCR_REDFLASH] = Font.FindFontColor("MiniRedFlash");
		GetMinimapColors();
		hnd = SWWMHandler(EventHandler.Find("SWWMHandler"));
		PrevFrame = MSTime();
		// fallback colors
		tclabel = Font.CR_FIRE;
		tcvalue = Font.CR_WHITE;
		tcextra = Font.CR_DARKGRAY;
		tccompl = Font.CR_GOLD;
		tcsucks = FONT.CR_RED;
		tclabel_s = "x";
		tcextra_s = "u";
	}

	private void DrawTarget()
	{
		// don't draw with automap open
		if ( automapactive || !swwm_ctrackers ) return;
		SWWMUtility.PrepareProjData(projdata,ViewPos,ViewRot.x,ViewRot.y,ViewRot.z,players[consoleplayer].fov);
		int cliptop = projdata.viewy, clipbottom = projdata.viewy+projdata.viewh,
			clipleft = projdata.viewx, clipright = projdata.viewx+projdata.vieww;
		let cam = players[consoleplayer].camera;
		Vector3 viewvec = (cos(viewrot.x)*cos(viewrot.y),sin(viewrot.x)*cos(viewrot.y),sin(-viewrot.y));
		if ( !cti ) cti = ThinkerIterator.Create("SWWMQuickCombatTracker",Thinker.STAT_INVENTORY);
		else cti.Reinit();
		SWWMQuickCombatTracker ct;
		double hsb = max(hs-1.,1.);	// always draw one level smaller
		Vector2 ssb = (Screen.GetWidth(),Screen.GetHeight())/hsb;
		while ( ct = SWWMQuickCombatTracker(cti.Next()) )
		{
			// ignore unowned (can happen?)
			if ( !ct.Owner ) continue;
			// ignore local player
			if ( ct.Owner == CPlayer.mo ) continue;
			// ignore trackers clearly outside of player view
			Vector3 smpos = level.Vec3Offset(ct.Owner.prev*(1.-fractic)+ct.Owner.pos*fractic,(0,0,ct.lvheight));
			Vector3 tdir = level.Vec3Diff(viewpos,smpos);
			if ( viewvec dot tdir < 0 ) continue;
			Vector3 ndc = SWWMUtility.ProjectPoint(projdata,viewpos+tdir);
			if ( ndc.z >= 1. ) continue;
			Vector2 vpos = SWWMUtility.NDCToViewport(projdata,ndc)/hsb;
			if ( !SWWMUtility.TestScreenBounds(projdata,vpos) ) continue;
			double fin = clamp(ct.fadein+fractic,0.,5.)/5.;
			double fout = clamp(ct.lifespan-fractic,0.,25.)/25.;
			double alph = fin*fout;
			Vector2 barpos = vpos-(27,7);
			Screen.DrawTexture(EnemyBTex,false,barpos.x,barpos.y,DTA_VirtualWidthF,ssb.x,DTA_VirtualHeightF,ssb.y,DTA_KeepRatio,true,DTA_Alpha,alph,DTA_ClipTop,cliptop,DTA_ClipBottom,clipbottom,DTA_ClipLeft,clipleft,DTA_ClipRight,clipright);
			int ht = clamp(ct.intp.GetValue(),0,ct.maxhealth);
			double hw = (ht*50.)/ct.maxhealth;
			Screen.DrawTexture(EnemyHTex[ct.Owner.bINVULNERABLE?1:0],false,barpos.x+2,barpos.y+2,DTA_VirtualWidthF,ssb.x,DTA_VirtualHeightF,ssb.y,DTA_KeepRatio,true,DTA_Alpha,alph,DTA_WindowRightF,hw,DTA_ClipTop,cliptop,DTA_ClipBottom,clipbottom,DTA_ClipLeft,clipleft,DTA_ClipRight,clipright);
			double ohw = hw;
			ht = clamp(ct.intpl.GetValue(),0,ct.maxhealth);
			hw = (ht*50.)/ct.maxhealth;
			Screen.DrawTexture(EnemyHTex[2],false,barpos.x+2,barpos.y+2,DTA_VirtualWidthF,ssb.x,DTA_VirtualHeightF,ssb.y,DTA_KeepRatio,true,DTA_Alpha,alph,DTA_WindowLeftF,ohw,DTA_WindowRightF,hw,DTA_ClipTop,cliptop,DTA_ClipBottom,clipbottom,DTA_ClipLeft,clipleft,DTA_ClipRight,clipright);
			if ( ct.cummdamage <= 0 ) continue;
			double calph = clamp(ct.cummspan-fractic,0.,20.)/20.;
			Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_RED],barpos.x+3,barpos.y+10,String.Format("%d",ct.cummdamage),DTA_VirtualWidthF,ssb.x,DTA_VirtualHeightF,ssb.y,DTA_KeepRatio,true,DTA_Alpha,calph*alph,DTA_ClipTop,cliptop,DTA_ClipBottom,clipbottom,DTA_ClipLeft,clipleft,DTA_ClipRight,clipright);
			if ( ct.cummflash <= 0 ) continue;
			double falph = max((ct.cummflash-FracTic)/15.,0.)**1.5;
			Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_REDFLASH],barpos.x+3,barpos.y+10,String.Format("%d",ct.cummdamage),DTA_VirtualWidthF,ssb.x,DTA_VirtualHeightF,ssb.y,DTA_KeepRatio,true,DTA_Alpha,falph*calph*alph,DTA_LegacyRenderStyle,STYLE_Add,DTA_ClipTop,cliptop,DTA_ClipBottom,clipbottom,DTA_ClipLeft,clipleft,DTA_ClipRight,clipright);
		}
	}

	override void DrawMyPos()
	{
		String str = String.Format("(%d,%d,%d)",CPlayer.mo.pos.X,CPlayer.mo.pos.Y,CPlayer.mo.pos.Z);
		Screen.DrawText(mTinyFont,Font.CR_GREEN,(ss.x-mTinyFont.StringWidth(str))/2,4,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
	}

	override void DrawAutomapHUD( double ticFrac )
	{
		// do nothing, DrawTopStuff handles this
	}

	// minimap helper code
	abstract void GetMinimapColors();	// this MUST be defined in each mod

	private bool ShouldDisplaySpecial( int special )
	{
		// thanks graf/randi/whoever
		switch ( special )
		{
		// the following have (max_args < 0)
		// but we can't know this from zscript, so they're hardcoded here
		case Polyobj_StartLine:
		case Polyobj_ExplicitLine:
		case Transfer_WallLight:
		case Sector_Attach3dMidtex:
		case ExtraFloor_LightOnly:
		case Sector_CopyScroller:
		case Scroll_Texture_Left:
		case Scroll_Texture_Right:
		case Scroll_Texture_Up:
		case Scroll_Texture_Down:
		case Plane_Copy:
		case Line_SetIdentification:
		case Line_SetPortal:
		case Sector_Set3DFloor:
		case Sector_SetContents:
		case Plane_Align:
		case Static_Init:
		case Transfer_Heights:
		case Transfer_FloorLight:
		case Transfer_CeilingLight:
		case Scroll_Texture_Model:
		case Scroll_Texture_Offsets:
		case PointPush_SetForce:
			return false;
		}
		return true;
	}
	private bool CheckSectorAction( Sector s, out int special, bool useonly )
	{
		for ( Actor act=s.SecActTarget; act; act=act.tracer )
		{
			if ( (act.Health&(SectorAction.SECSPAC_Use|SectorAction.SECSPAC_UseWall) || !useonly)
				&& act.special && !act.bFRIENDLY )
			{
				special = act.special;
				return true;
			}
		}
		return false;
	}
	private bool RealLineSpecial( Line l, out int special )
	{
		if ( special && l.activation&SPAC_PlayerActivate )
			return true;
		if ( CheckSectorAction(l.frontsector,special,!l.backsector) )
			return true;
		return (l.backsector && CheckSectorAction(l.backsector,special,false));
	}
	private bool ShowTriggerLine( Line l )
	{
		if ( am_showtriggerlines == 0 ) return false;
		int special = l.special;
		if ( !RealLineSpecial(l,special) ) return false;
		if ( !ShouldDisplaySpecial(special) ) return false;
		if ( special && (am_showtriggerlines >= 2) ) return true;
		if ( !special || (special == Door_Open)
			|| (special == Door_Close)
			|| (special == Door_CloseWaitOpen)
			|| (special == Door_Raise)
			|| (special == Door_Animated)
			|| (special == Generic_Door) )
			return false;
		return true;
	}
	private bool CmpFloorPlanes( Line l )
	{
		return (l.frontsector.floorplane.Normal == l.backsector.floorplane.Normal)
			&& (l.frontsector.floorplane.D == l.backsector.floorplane.D);
	}
	private bool CmpCeilingPlanes( Line l )
	{
		return (l.frontsector.ceilingplane.Normal == l.backsector.ceilingplane.Normal)
			&& (l.frontsector.ceilingplane.D == l.backsector.ceilingplane.D);
	}

	private int CheckSecret( Line l )
	{
		if ( !mm_secretsectorcolor || !mm_unexploredsecretcolor )
			return 0;
		if ( l.frontsector && (l.frontsector.flags&Sector.SECF_WASSECRET) )
		{
			if ( am_map_secrets && !(l.frontsector.flags&Sector.SECF_SECRET) ) return 1;
			if ( (am_map_secrets == 2) && !(l.flags&Line.ML_SECRET) ) return 2;
		}
		if ( l.backsector && (l.backsector.flags&Sector.SECF_WASSECRET) )
		{
			if ( am_map_secrets && !(l.backsector.flags&Sector.SECF_SECRET) ) return 1;
			if ( (am_map_secrets == 2) && !(l.flags&Line.ML_SECRET) ) return 2;
		}
		return 0;
	}
	private bool CheckFFBoundary( Line l )
	{
		if ( !hnd || !hnd.ffsectors.Size() ) return false;
		int frontidx = hnd.ffsectors.Find(l.frontsector.Index());
		int backidx = hnd.ffsectors.Find(l.backsector.Index());
		// no 3D floors, no boundary
		if ( (frontidx == hnd.ffsectors.Size()) && (backidx == frontidx) )
			return false;
		return true;
	}

	private void DrawMapLines( Vector2 basepos )
	{
		double zoomlevel = oldminimapzoom*(1.-FracTic)+minimapzoom*FracTic;
		double zoomview = MAPVIEWDIST*zoomlevel, zoomclip = CLIPDIST*zoomlevel;
		Vector2 cpos = players[consoleplayer].Camera.prev.xy*(1.-FracTic)+players[consoleplayer].Camera.pos.xy*FracTic;
		Sector csec = players[consoleplayer].Camera.CurSector;
		for ( int i=0; i<level.lines.Size(); i++ )
		{
			Line l = level.lines[i];
			if ( !(l.flags&Line.ML_MAPPED) && !level.allmap && !am_cheat ) continue;
			if ( (l.flags&Line.ML_DONTDRAW) && ((am_cheat == 0) || (am_cheat >= 4)) )
				continue;
			Vector2 rv1 = l.v1.p-cpos, rv2 = l.v2.p-cpos;
			bool isportal = false;
			Sector linesector;
			if ( l.sidedef[0].flags&Side.WALLF_POLYOBJ ) linesector = level.PointInSector(l.v1.p+l.delta/2.);
			else linesector = l.frontsector;
			isportal = (linesector.portalgroup!=csec.portalgroup);
			if ( isportal )
			{
				// portal displacement
				Vector2 pofs = SWWMUtility.PortalDisplacement(csec,linesector);
				rv1 -= pofs;
				rv2 -= pofs;
			}
			Vector2 mid = (rv1+rv2)/2.;
			Vector2 siz = (abs(rv1.x-rv2.x),abs(rv1.y-rv2.y))/2.;
			if ( (((siz.x+zoomview)-abs(mid.x)) <= 0) || (((siz.y+zoomview)-abs(mid.y)) <= 0) )
				continue;
			// flip Y
			rv1.y *= -1;
			rv2.y *= -1;
			// rotate by view
			rv1 = Actor.RotateVector(rv1,ViewRot.x-90);
			rv2 = Actor.RotateVector(rv2,ViewRot.x-90);
			// clip to frame
			bool visible;
			[visible, rv1, rv2] = SWWMUtility.LiangBarsky((-1,-1)*zoomclip,(1,1)*zoomclip,rv1,rv2);
			if ( !visible ) continue;
			// scale to minimap frame
			rv1 *= (HALFMAPSIZE/zoomclip)*hs;
			rv2 *= (HALFMAPSIZE/zoomclip)*hs;
			// offset to minimap center
			rv1 += basepos;
			rv2 += basepos;
			// get the line color
			Color col = mm_wallcolor;
			if ( (l.flags&Line.ML_MAPPED) || am_cheat )
			{
				int secwit = CheckSecret(l);
				int lock = SWWMUtility.GetLineLock(l);
				if ( secwit == 1 ) col = mm_secretsectorcolor;
				else if ( secwit == 2 ) col = mm_unexploredsecretcolor;
				else if ( l.flags&Line.ML_SECRET )
				{
					if ( am_cheat && l.backsector && mm_secretwallcolor )
						col = mm_secretwallcolor;
					else col = mm_wallcolor;
				}
				else if ( mm_interlevelcolor
					&& ((l.special == Exit_Normal)
					|| (l.special == Exit_Secret)
					|| (l.special == Teleport_NewMap)
					|| (l.special == Teleport_EndGame)) )
					col = mm_interlevelcolor;
				else if ( mm_intralevelcolor &&
					(l.activation&SPAC_PlayerActivate)
					&& ((l.special == Teleport)
					|| (l.special == Teleport_NoFog)
					|| (l.special == Teleport_ZombieChanger)
					|| (l.special == Teleport_Line)) )
					col = mm_intralevelcolor;
				else if ( (lock > 0) && (lock < 256) )
				{
					let lcol = SWWMUtility.GetLockColor(lock);
					if ( lcol ) col = lcol;
					else col = mm_lockedcolor;
				}
				else if ( mm_specialwallcolor && ShowTriggerLine(l) )
					col = mm_specialwallcolor;
				else if ( l.frontsector && l.backsector )
				{
					if ( !CmpFloorPlanes(l) ) col = mm_fdwallcolor;
					else if ( !CmpCeilingPlanes(l) ) col = mm_cdwallcolor;
					else if ( CheckFFBoundary(l) ) col = mm_efwallcolor;
					else
					{
						if ( (am_cheat == 0) || (am_cheat >= 4) )
							continue;
						col = mm_tswallcolor;
					}
				}
			}
			else col = mm_notseencolor;
			// draw the line
			if ( isportal )
			{
				col = Color((col.r+mm_portalcolor.r*7)/8,(col.g+mm_portalcolor.g*7)/8,(col.b+mm_portalcolor.b*7)/8);
				Screen.DrawThickLine(int(rv1.x),int(rv1.y),int(rv2.x),int(rv2.y),max(1.,hs*.25),col);
			}
			else Screen.DrawThickLine(int(rv1.x),int(rv1.y),int(rv2.x),int(rv2.y),max(1.,hs*.5),col);
		}
	}

	private void DrawMapMarkers( Vector2 basepos )
	{
		double zoomlevel = oldminimapzoom*(1.-FracTic)+minimapzoom*FracTic;
		double zoomview = MAPVIEWDIST*zoomlevel, zoomclip = CLIPDIST*zoomlevel;
		Vector2 cpos = players[consoleplayer].Camera.prev.xy*(1.-FracTic)+players[consoleplayer].Camera.pos.xy*FracTic;
		Sector csec = players[consoleplayer].Camera.CurSector;
		if ( !mi ) mi = ThinkerIterator.Create("MapMarker",Thinker.STAT_MAPMARKER);
		else mi.Reinit();
		MapMarker m;
		while ( m = MapMarker(mi.Next()) )
		{
			if ( m.bDORMANT ) continue;
			if ( m.args[1] && !(m.CurSector.moreflags&Sector.SECMF_DRAWN) ) continue;
			TextureID tx;
			if ( m.picnum.IsValid() ) tx = m.picnum;
			else tx = m.CurState.GetSpriteTexture(1);
			Vector2 sz = TexMan.GetScaledSize(tx);
			Vector2 scl;
			// seems to match automap scaling somewhat
			if ( m.Args[2] ) scl = (m.Scale/zoomlevel)*.15;
			else scl = m.Scale*.5;
			sz.x *= scl.x;
			sz.y *= scl.y;
			double radius = max(sz.x,sz.y);	// naive, I know
			if ( m.args[0] )
			{
				// oh bother, this will be dicks
				let ai = level.CreateActorIterator(m.args[0]);
				Actor a;
				while ( a = ai.Next() )
				{
					Vector2 rv = a.pos.xy-cpos;
					bool isportal = false;
					Sector sec = level.PointInSector(a.pos.xy);
					if ( sec.portalgroup != csec.portalgroup )
					{
						isportal = true;
						// portal displacement
						rv -= SWWMUtility.PortalDisplacement(csec,sec);
					}
					if ( (((radius+zoomview)-abs(rv.x)) <= 0) || (((radius+zoomview)-abs(rv.y)) <= 0) )
						continue;
					// flip Y
					rv.y *= -1;
					// rotate by view
					rv = Actor.RotateVector(rv,ViewRot.x-90);
					// scale to minimap frame
					rv *= (HALFMAPSIZE/zoomclip)*hs;
					// offset to minimap center
					rv += basepos;
					// draw
					int clipleft = int((basepos.x-HALFMAPSIZE)*hs);
					int cliptop = int((basepos.y-HALFMAPSIZE)*hs);
					int clipright = int(clipleft+HALFMAPSIZE*2*hs);
					int clipbottom = int(cliptop+HALFMAPSIZE*2*hs);
					Screen.DrawTexture(tx,false,rv.x,rv.y,DTA_ColorOverlay,isportal?Color(128,mm_portalcolor.r,mm_portalcolor.g,mm_portalcolor.b):Color(0,0,0,0),DTA_ScaleX,hs*scl.x,DTA_ScaleY,hs*scl.y,DTA_LegacyRenderStyle,m.GetRenderStyle(),DTA_Alpha,m.Alpha,DTA_FillColor,m.FillColor,DTA_TranslationIndex,m.Translation,DTA_ClipLeft,clipleft,DTA_ClipTop,cliptop,DTA_ClipRight,clipright,DTA_ClipBottom,clipbottom);
				}
				ai.Destroy();
				continue;
			}
			Vector2 rv = m.pos.xy-cpos;
			bool isportal = false;
			Sector sec = level.PointInSector(m.pos.xy);
			if ( sec.portalgroup != csec.portalgroup )
			{
				isportal = true;
				// portal displacement
				rv -= SWWMUtility.PortalDisplacement(csec,sec);
			}
			if ( (((radius+zoomview)-abs(rv.x)) <= 0) || (((radius+zoomview)-abs(rv.y)) <= 0) )
				continue;
			// flip Y
			rv.y *= -1;
			// rotate by view
			rv = Actor.RotateVector(rv,ViewRot.x-90);
			// scale to minimap frame
			rv *= (HALFMAPSIZE/zoomclip)*hs;
			// offset to minimap center
			rv += basepos;
			// draw
			int clipleft = int(basepos.x-HALFMAPSIZE*hs);
			int cliptop = int(basepos.y-HALFMAPSIZE*hs);
			int clipright = int(clipleft+HALFMAPSIZE*2*hs);
			int clipbottom = int(cliptop+HALFMAPSIZE*2*hs);
			Screen.DrawTexture(tx,false,rv.x,rv.y,DTA_ColorOverlay,isportal?Color(128,mm_portalcolor.r,mm_portalcolor.g,mm_portalcolor.b):Color(0,0,0,0),DTA_ScaleX,hs*scl.x,DTA_ScaleY,hs*scl.y,DTA_LegacyRenderStyle,m.GetRenderStyle(),DTA_Alpha,m.Alpha,DTA_FillColor,m.FillColor,DTA_TranslationIndex,m.Translation,DTA_ClipLeft,clipleft,DTA_ClipTop,cliptop,DTA_ClipRight,clipright,DTA_ClipBottom,clipbottom);
		}
	}

	// actually does nothing since actor displays are a Demolitionist-exclusive feature
	// but kept around and made virtual so side mods can draw their own stuff here
	// (e.g.: show special markers or whatever)
	virtual void DrawMapThings( Vector2 basepos )
	{
	}

	private void DrawTopStuff()
	{
		// obviously, don't draw the minimap if the automap is open
		int xx, yy = margin;
		if ( !automapactive && swwm_mm_enable )
		{
			xx = int(ss.x-(margin+(HALFMAPSIZE+2)*2));
			Screen.DrawTexture(MiniBox,false,xx,yy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			Vector2 basemappos = (xx+HALFMAPSIZE+2,yy+HALFMAPSIZE+2);
			Screen.Dim(mm_backcolor,1.,int((basemappos.x-HALFMAPSIZE)*hs),int((basemappos.y-HALFMAPSIZE)*hs),int(HALFMAPSIZE*2*hs),int(HALFMAPSIZE*2*hs));
			// draw dat stuff
			DrawMapLines(basemappos*hs);
			DrawMapThings(basemappos*hs);
			DrawMapMarkers(basemappos*hs);
			// draw the player arrow
			Vector2 tv[3];
			tv[0] = (0,-4);
			tv[1] = (-3,2);
			tv[2] = (3,2);
			for ( int i=0; i<3; i++ ) tv[i] = (tv[i]+basemappos)*hs;
			for ( int i=0; i<3; i++ ) Screen.DrawThickLine(int(tv[i].x),int(tv[i].y),int(tv[(i+1)%3].x),int(tv[(i+1)%3].y),max(1.,hs*.5),mm_yourcolor);
			yy += ((HALFMAPSIZE+2)*2)+5;
		}
		// draw stats and timer when automap is open
		int fstats = swwm_forcestats;
		if ( automapactive || (fstats > 0) )
		{
			xx = int(ss.x-(margin+2));
			String str;
			if ( automapactive || (fstats > 1) )
			{
				int label = am_showmaplabel;
				String ln = level.levelname;
				int iof = ln.IndexOf(" - by: ");
				if ( iof != -1 ) ln.Truncate(iof);
				if ( !label || ((level.clusterflags&level.CLUSTER_HUB) && (label == 2)) ) str = ln;
				else str = String.Format("%s - %s",level.mapname.MakeUpper(),ln);
				Screen.DrawText(mBigFont,tclabel,xx-mBigFont.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				yy += mBigFont.GetHeight()+4;
			}
			if ( (level.total_monsters > 0) && am_showmonsters && !deathmatch )
			{
				str = String.Format("\c"..tclabel_s.."K \c-%d\c"..tcextra_s.."/\c-%d",level.killed_monsters,level.total_monsters);
				Screen.DrawText(MiniHUDFontOutline,(level.killed_monsters>=level.total_monsters)?tccompl:tcvalue,xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				if ( killflash && (gametic < killflash) )
				{
					double alph = max((killflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d/%d",level.killed_monsters,level.total_monsters);
					int slashpos = str.IndexOf("/");
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str.Left(slashpos),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				if ( tkillflash && (gametic < tkillflash) )
				{
					double alph = max((tkillflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d",level.total_monsters);
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				yy += MiniHUDFontOutline.GetHeight()+2;
			}
			if ( (level.total_items > 0) && am_showitems && !deathmatch )
			{
				str = String.Format("\c"..tclabel_s.."I \c-%d\c"..tcextra_s.."/\c-%d",level.found_items,level.total_items);
				Screen.DrawText(MiniHUDFontOutline,(level.found_items>=level.total_items)?tccompl:tcvalue,xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				if ( itemflash && (gametic < itemflash) )
				{
					double alph = max((itemflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d/%d",level.found_items,level.total_items);
					int slashpos = str.IndexOf("/");
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str.Left(slashpos),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				if ( titemflash && (gametic < titemflash) )
				{
					double alph = max((titemflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d",level.total_items);
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				yy += MiniHUDFontOutline.GetHeight()+2;
			}
			if ( (level.total_secrets > 0) && am_showsecrets && !deathmatch )
			{
				str = String.Format("\c"..tclabel_s.."S \c-%d\c"..tcextra_s.."/\c-%d",level.found_secrets,level.total_secrets);
				Screen.DrawText(MiniHUDFontOutline,(level.found_secrets>=level.total_secrets)?tccompl:tcvalue,xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				if ( secretflash && (gametic < secretflash) )
				{
					double alph = max((secretflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d/%d",level.found_secrets,level.total_secrets);
					int slashpos = str.IndexOf("/");
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str.Left(slashpos),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				if ( tsecretflash && (gametic < tsecretflash) )
				{
					double alph = max((tsecretflash-(gametic+FracTic))/25.,0.)**1.5;
					str = String.Format("%d",level.total_secrets);
					Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_FLASH],xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				}
				yy += MiniHUDFontOutline.GetHeight()+2;
			}
			int sec;
			if ( am_showtime )
			{
				sec = Thinker.Tics2Seconds(level.maptime);
				str = String.Format("\c"..tclabel_s.."T \c-%02d\c"..tcextra_s..":\c-%02d\c"..tcextra_s..":\c-%02d",sec/3600,(sec%3600)/60,sec%60);
				Screen.DrawText(MiniHUDFontOutline,((level.sucktime>0)&&(sec>=(level.sucktime*3600)))?tcsucks:((level.partime>0)&&(sec<=level.partime))?tccompl:tcvalue,xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				yy += MiniHUDFontOutline.GetHeight()+2;
			}
			// don't show total time if it's equal to map time
			if ( am_showtotaltime && (level.totaltime != level.maptime) )
			{
				sec = Thinker.Tics2Seconds(level.totaltime);
				str = String.Format("\c"..tclabel_s.."TT \c-%02d\c"..tcextra_s..":\c-%02d\c"..tcextra_s..":\c-%02d",sec/3600,(sec%3600)/60,sec%60);
				Screen.DrawText(MiniHUDFontOutline,tcvalue,xx-MiniHUDFontOutline.StringWidth(str),yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				yy += MiniHUDFontOutline.GetHeight()+2;
			}
			yy += 3;
		}
		// draw key icons
		Vector2 keypos = (ss.x-(margin+2),yy);
		int colc = 0;
		double colh = 0;
		int n = Key.GetKeyTypeCount();
		Array<Key> klist;
		for ( int i=0; i<n; i++ )
		{
			let k = Key(CPlayer.mo.FindInventory(Key.GetKeyType(i)));
			if ( !k || !k.Icon.IsValid() ) continue;
			klist.Push(k);
		}
		int maxcolc = (gameinfo.gametype&GAME_DOOMCHEX)?6:4;
		for ( int i=0; i<klist.Size(); i++ )
		{
			let k = klist[i];
			// Hexen key icons aren't meant for this kind of HUD
			TextureID icon = (k is 'HexenKey')?k.SpawnState.GetSpriteTexture(0):k.Icon;
			Vector2 siz = TexMan.GetScaledSize(icon);
			Screen.DrawTexture(icon,false,keypos.x-siz.x,keypos.y,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_TopLeft,true);
			for ( int j=0; j<keyflash.Size(); j++ )
			{
				if ( !(k is keyflash[j].got) ) continue;
				if ( !keyflash[j].flashtime || (gametic >= keyflash[j].flashtime) ) continue;
				double alph = max((keyflash[j].flashtime-(gametic+FracTic))/25.,0.)**1.5;
				Screen.DrawTexture(icon,false,keypos.x-siz.x,keypos.y,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_TopLeft,true,DTA_ColorOverlay,0xFFFFC040,DTA_LegacyRenderStyle,STYLE_Add,DTA_Alpha,alph);
				break;
			}
			keypos.x -= siz.x+2;
			colh = max(colh,siz.y);
			if ( ++colc == maxcolc )
			{
				keypos.x = ss.x-(margin+2);
				keypos.y += colh+2;
				colh = colc = 0;
			}
		}
	}

	protected bool DrawInvIcon( Inventory i, double xx, double yy, double alpha = 1., bool forceamt = false, bool selected = false, bool aspowerup = false )
	{
		if ( !i || !i.Icon.IsValid() ) return false;
		Vector2 scl = TexMan.GetScaledSize(i.Icon);
		double mscl = min(1.,20/max(scl.x,scl.y));
		double dw = (ss.x/mscl), dh = (ss.y/mscl);
		double dx = (xx+(20-scl.x*mscl)/2)/mscl, dy = (yy+(20-scl.y*mscl)/2)/mscl;
		if ( i is 'Powerup' )
		{
			bool isinfinite = ((i is 'PowerStrength') || ((i is 'PowerFlight') && !multiplayer && level.infinite_flight));
			Screen.DrawTexture(i.Icon,false,dx,dy,DTA_VirtualWidthF,dw,DTA_VirtualHeightF,dh,DTA_KeepRatio,true,DTA_Alpha,(!isinfinite&&Powerup(i).IsBlinking())?alpha*.5:alpha,DTA_TopOffset,0,DTA_LeftOffset,0);
			String nstr;
			// handle "infinite" durations
			if ( isinfinite ) nstr = "∞";
			else nstr = String.Format("%ds",Powerup(i).EffectTics/GameTicRate);
			int len = MiniHUDFontOutline.StringWidth(nstr);
			Screen.DrawText(MiniHUDFontOutline,mhudfontcol[MCR_BRASS],(xx+20)-len,(yy+20)-7,nstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,(!isinfinite&&Powerup(i).IsBlinking())?alpha*.5:alpha);
			return true;
		}
		if ( (i is 'SWWMChargeItem') && aspowerup )
		{
			Screen.DrawTexture(i.Icon,false,dx,dy,DTA_VirtualWidthF,dw,DTA_VirtualHeightF,dh,DTA_KeepRatio,true,DTA_Alpha,SWWMChargeItem(i).IsBlinking()?alpha*.5:alpha,DTA_TopOffset,0,DTA_LeftOffset,0);
			String nstr = String.Format("%ds",SWWMChargeItem(i).Charge/GameTicRate);
			int len = MiniHUDFontOutline.StringWidth(nstr);
			Screen.DrawText(MiniHUDFontOutline,mhudfontcol[SWWMChargeItem(i).bActive?MCR_BRASS:MCR_WHITE],(xx+20)-len,(yy+20)-7,nstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,SWWMChargeItem(i).IsBlinking()?alpha*.5:alpha);
			return true;
		}
		Screen.DrawTexture(i.Icon,false,dx,dy,DTA_VirtualWidthF,dw,DTA_VirtualHeightF,dh,DTA_KeepRatio,true,DTA_Alpha,alpha,DTA_TopOffset,0,DTA_LeftOffset,0,DTA_ColorOverlay,(i.Amount<=0)?Color(128,0,0,0):Color(0,0,0,0));
		if ( (i.Amount > 1) || forceamt )
		{
			String nstr;
			if ( (i.Amount > 99999) && !forceamt ) nstr = "99999";
			else nstr = String.Format("%d",i.Amount);
			int len = MiniHUDFontOutline.StringWidth(nstr);
			Screen.DrawText(MiniHUDFontOutline,mhudfontcol[(i.Amount<=0)?MCR_RED:selected?MCR_BRASS:MCR_WHITE],(xx+20)-len,(yy+20)-6,nstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alpha);
		}
		return true;
	}

	private void DrawInventory( int invy )
	{
		// active items (armor / powerups)
		double xx = margin+2;
		double yy = ss.y-(margin+invy);
		if ( bAlwaysDrawInv || (CPlayer.mo.InvSel && !isInventoryBarVisible()) ) yy -= 24+AboveInvOffset;
		bool drewarmor = false;
		for ( Inventory i=CPlayer.mo.Inv; i; i=i.Inv )
		{
			if ( (i.Amount <= 0) || (!(i is 'SWWMArmor') && !(i is 'BasicArmor')) ) continue;
			if ( !DrawInvIcon(i,xx,yy,forceamt:true,selected:true) ) continue;
			yy -= 24;
			drewarmor = true;
		}
		yy = ss.y-(margin+invy);
		if ( drewarmor )
		{
			xx += 30;
			if ( bAlwaysAboveInv && (bAlwaysDrawInv || (CPlayer.mo.InvSel && !isInventoryBarVisible())) )
				yy -= 24+AboveInvOffset;
		}
		else if ( bAlwaysDrawInv || (CPlayer.mo.InvSel && !isInventoryBarVisible()) ) yy -= 24;
		for ( Inventory i=CPlayer.mo.Inv; i; i=i.Inv )
		{
			if ( !((i is 'SWWMChargeItem') && SWWMChargeItem(i).bActivated) && !((i is 'Powerup') && (Powerup(i).EffectTics > 0)) )
				continue;
			if ( DrawInvIcon(i,xx,yy,selected:true,aspowerup:true) )
				yy -= 24;
		}
		// inventory box / bar
		if ( !CPlayer.mo.InvSel )
		{
			if ( bAlwaysDrawInv )
				Screen.DrawTexture(InventoryTex,false,margin,ss.y-(margin+invy+2),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			return;
		}
		if ( isInventoryBarVisible() )
		{
			Array<Inventory> bar;
			bar.Clear();
			for ( Inventory i=CPlayer.mo.FirstInv(); i; i=i.NextInv() ) bar.Push(i);
			int ps = bar.Find(CPlayer.mo.InvSel);
			Inventory prev[2], next[2];
			if ( bar.Size() > 1 )
			{
				if ( ps+1 >= bar.Size() ) next[0] = bar[0];
				else next[0] = bar[ps+1];
				if ( ps-1 < 0 ) prev[0] = bar[bar.Size()-1];
				else prev[0] = bar[ps-1];
			}
			if ( bar.Size() > 2 )
			{
				if ( ps+2 >= bar.Size() ) next[1] = bar[(ps+2)-bar.Size()];
				else next[1] = bar[ps+2];
				if ( ps-2 < 0 ) prev[1] = bar[bar.Size()+(ps-2)];
				else prev[1] = bar[ps-2];
			}
			double xx = (ss.x-24)/2;
			double yy = (ss.y+52)/2;
			Screen.DrawTexture(InventoryTex,false,xx,yy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			DrawInvIcon(prev[1],xx-46,yy+2,1./3.);
			DrawInvIcon(prev[0],xx-22,yy+2,2./3.);
			DrawInvIcon(CPlayer.mo.InvSel,xx+2,yy+2,selected:true);
			DrawInvIcon(next[0],xx+26,yy+2,2./3.);
			DrawInvIcon(next[1],xx+50,yy+2,1./3.);
			return;
		}
		Screen.DrawTexture(InventoryTex,false,margin,ss.y-(margin+invy+2),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		DrawInvIcon(CPlayer.mo.InvSel,margin+2,ss.y-(margin+invy),selected:true);
	}

	abstract void DrawWeapons();

	abstract int DrawStatus();

	private void DrawPickups()
	{
		int h = mSmallFont.GetHeight();
		// draw nametags below them
		double yy;
		double nalph = 0.;
		double tagtime = (ntagtic+70)-(level.totaltime+fractic);
		if ( (ntagstr != "") && (tagtime > 0) )
		{
			nalph = clamp(tagtime/20.,0.,1.);
			yy = ss.y-(margin+50);
			int len = mSmallFont.StringWidth(ntagstr);
			double xx = (ss.x-len)/2.;
			Screen.Dim("Black",.8*nalph,int((xx-6)*hs),int(yy*hs),int((len+12)*hs),int((h+4)*hs));
			Screen.DrawText(mSmallFont,ntagcol,int(xx),yy+2,ntagstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,nalph);
		}
		if ( PickupQueue.Size() <= 0 ) return;
		// reverse order since they're drawn bottom to top
		int mend = max(0,PickupQueue.Size()-swwm_maxpickup);
		yy = ss.y-(margin+50);
		// shift up if nametag is present
		if ( nalph > 0. ) yy -= int((mSmallFont.GetHeight()+6)*clamp(nalph*2.,0.,1.));
		for ( int i=PickupQueue.Size()-1; i>=mend; i-- )
		{
			PickupQueue[i].UpdateText(int(ss.x*.75));
			double curtime = (PickupQueue[i].tic+GameTicRate*swwm_pickduration)-(level.totaltime+fractic);
			double alph = clamp(curtime/20.,0.,1.);
			let l = PickupQueue[i].l;
			int maxlen = 0;
			for ( int j=0; j<l.Count(); j++ )
			{
				int len = mSmallFont.StringWidth(l.StringAt(j));
				if ( len > maxlen ) maxlen = len;
			}
			double xx = (ss.x-maxlen)/2.;
			Screen.Dim("Black",.8*alph,int((xx-6)*hs),int((yy-h*(l.Count()-1))*hs),int((maxlen+12)*hs),int((h*l.Count()+4)*hs));
			for ( int j=l.Count()-1; j>=0; j-- )
			{
				int len = mSmallFont.StringWidth(l.StringAt(j));
				xx = int((ss.x-len)/2.);
				Screen.DrawText(mSmallFont,msg0color,xx,yy+2,l.StringAt(j),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alph);
				yy -= h;
			}
			yy -= 6;
		}
	}

	private void DrawMessages( double boxalph = 1. )
	{
		double xx, yy;
		if ( midstr != "" )
		{
			double ssp = (midtype&1)?.5:1.;
			double hsp = (midtype&1)?2.:1.;
			int col = (midtype&2)?msgmidcolor2:msgmidcolor;
			double curtime = (midtic+int(GameTicRate*con_midtime))-(level.totaltime+fractic);
			double alph = clamp(curtime/20.,0.,1.);
			if ( !midl || (midsz != int(ss.x*ssp)) )
			{
				if ( midl ) midl.Destroy();
				midl = mSmallFont.BreakLines(midstr,int(ss.x*ssp));
			}
			int h = mSmallFont.GetHeight();
			int maxlen = 0;
			for ( int i=0; i<midl.Count(); i++ ) maxlen = max(maxlen,mSmallFont.StringWidth(midl.StringAt(i)));
			xx = int((ss.x*ssp-maxlen)/2.);
			yy = ss.y*ssp*.375;
			yy -= (h*midl.Count()+4)/2;	// center
			Screen.Dim("Black",.8*alph,int((xx-6)*hs*hsp),int(yy*hs*hsp),int((maxlen+12)*hs*hsp),int((h*midl.Count()+4)*hs*hsp));
			for ( int i=0; i<midl.Count(); i++ )
			{
				int len = mSmallFont.StringWidth(midl.StringAt(i));
				xx = int((ss.x*ssp-len)/2.);
				Screen.DrawText(mSmallFont,col,int(xx),yy+2,midl.StringAt(i),DTA_VirtualWidthF,ss.x*ssp,DTA_VirtualHeightF,ss.y*ssp,DTA_KeepRatio,true,DTA_Alpha,alph);
				yy += h;
			}
		}
		if ( MainQueue.Size() <= 0 ) return;
		int mstart = max(0,MainQueue.Size()-((chatopen>=gametic)?swwm_maxshownbig:swwm_maxshown));
		xx = margin;
		yy = margin;
		bool smol = (ss.x<640);
		Screen.DrawTexture(ChatTex[smol?3:0],false,xx,yy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,boxalph);
		yy += 2;
		for ( int i=mstart; i<MainQueue.Size(); i++ )
		{
			int col = msg2color;
			if ( MainQueue[i].type == PRINT_MEDIUM ) col = msg1color;
			else if ( MainQueue[i].type == PRINT_CHAT ) col = msg3color;
			else if ( MainQueue[i].type == PRINT_TEAMCHAT ) col = msg4color;
			MainQueue[i].UpdateText();
			let l = smol?MainQueue[i].ls:MainQueue[i].l;
			double curtime = MainQueue[i].tic-(level.totaltime+fractic);
			if ( MainQueue[i].type < PRINT_CHAT ) curtime += GameTicRate*swwm_msgduration;
			else curtime += GameTicRate*swwm_chatduration;
			double alph = clamp(curtime/20.,0.,1.);
			for ( int j=0; j<l.Count(); j++ )
			{
				Screen.DrawTexture(ChatTex[smol?4:1],false,xx,yy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,boxalph);
				Screen.DrawText(mSmallFont,col,xx+4,yy,l.StringAt(j),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alph);
				yy += 13;
			}
		}
		Screen.DrawTexture(ChatTex[smol?5:2],false,xx,yy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,boxalph);
	}

	override bool DrawChat( String txt )
	{
		// ignore during intermission
		if ( gamestate != GS_LEVEL ) return false;
		chatopen = gametic+1;	// have to add 1 because DrawChat is called after everything else
		double xx = 2;
		double yy = ss.y-14;
		Screen.Dim("Black",.8,0,Screen.GetHeight()-int(15*hs),Screen.GetWidth(),int(15*hs));
		String fullstr = String.Format("\cd(>\c- %s_",txt);
		// cut out to fit
		int w = mSmallFont.StringWidth(fullstr);
		if ( w > ss.x-4 )
		{
			// draw trailing dots
			Screen.DrawText(mSmallFont,Font.CR_WHITE,xx,yy,"...",DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			// shift back
			xx -= w-(ss.x-4);
			// draw trimmed
			Screen.DrawText(mSmallFont,Font.CR_WHITE,xx,yy,fullstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_ClipLeft,int(26*hs));
		}
		else Screen.DrawText(mSmallFont,Font.CR_WHITE,xx,yy,fullstr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		return true;
	}

	override bool DrawPaused( int player )
	{
		let fnt = mBigFont?mBigFont:NewSmallFont;
		let fnt2 = mSmallFont?mSmallFont:NewConsoleFont;
		if ( swwm_fuzz )
		{
			Vector2 tsize = TexMan.GetScaledSize(bgtex);
			double zoom = max(ceil(Screen.GetWidth()/tsize.x),ceil(Screen.GetHeight()/tsize.y));
			Vector2 vsize = (Screen.GetWidth(),Screen.GetHeight())/zoom;
			Screen.DrawTexture(bgtex,false,(vsize.x-tsize.x)/2,(vsize.y-tsize.y)/2,DTA_VirtualWidthF,vsize.x,DTA_VirtualHeightF,vsize.y,DTA_KeepRatio,true,DTA_ColorOverlay,Color(192,0,0,0),DTA_Alpha,.5);
		}
		else Screen.Dim("Black",.5,0,0,Screen.GetWidth(),Screen.GetHeight());
		String str = StringTable.Localize("$SWWM_PAUSE");
		if ( gametic < pausetime+1000 )
		{
			pausepos.x = Screen.GetWidth()/2;
			pausepos.y = Screen.GetHeight()/2;
			pausedir = (1,1);
		}
		else
		{
			pausepos.x += pausedir.x*CleanXFac;
			pausepos.y += pausedir.y*CleanYFac;
			if ( pausepos.x >= Screen.GetWidth()-((fnt.StringWidth(str)*3+8)*CleanXFac/2) )
				pausedir.x = -1;
			if ( pausepos.x < ((fnt.StringWidth(str)*3+8)*CleanXFac/2) )
				pausedir.x = 1;
			if ( pausepos.y >= Screen.GetHeight()-((fnt.GetHeight()*3+8)*CleanYFac/2) )
				pausedir.y = -1;
			if ( pausepos.y < ((fnt.GetHeight()*3+8)*CleanYFac/2) )
				pausedir.y = 1;
		}
		double xx = pausepos.x-(fnt.StringWidth(str)*3*CleanXFac)/2;
		double yy = pausepos.y-(fnt.GetHeight()*3*CleanYFac)/2;
		int tlen = str.CodePointCount();
		for ( int i=0, pos=0; i<tlen; i++ )
		{
			int ch;
			[ch, pos] = str.GetNextCodePoint(pos);
			Screen.DrawChar(fnt,Font.CR_BLUE,xx,yy+4*sin(32*i+8*gametic)*CleanYFac,ch,DTA_ScaleX,CleanXFac*3,DTA_ScaleY,CleanYFac*3);
			xx += (fnt.GetCharWidth(ch)+fnt.GetDefaultKerning())*3*CleanXFac;
		}
		yy += fnt.GetHeight()*3*CleanYFac;
		if ( multiplayer && (player != -1) )
		{
			str = String.Format(StringTable.Localize("$TXT_BY"),players[player].GetUserName());
			xx = pausepos.x-fnt2.StringWidth(str)*CleanXFac/2;
			Screen.DrawText(fnt2,Font.CR_WHITE,xx,yy,str,DTA_CleanNoMove,true);
		}
		return true;
	}

	override void DrawPowerups()
	{
		// don't do anything, this is handled by DrawInventory
	}

	private double DrawDeath()
	{
		// death prompt
		let demo = SWWMPlayer(CPlayer.mo);
		if ( !demo || (CPlayer.Health > 0) || (CPlayer != players[consoleplayer]) ) return 1.;
		String str;
		double alph;
		int len;
		double xx, yy;
		double deadtimer = demo.deadtimer+fractic;
		if ( demo.player.viewheight > 6 ) return 1.;
		double dimalph = min(deadtimer/80.,.8);
		Screen.Dim("Black",dimalph,0,0,Screen.GetWidth(),Screen.GetHeight());
		alph = clamp((deadtimer-60)/60.,0.,1.);
		str = StringTable.Localize("$SWWM_URDED");
		len = mBigFont.StringWidth(str);
		xx = int((ss.x-len*4)/2.);
		yy = (ss.y-(mBigFont.GetHeight()*4+48))/2.;
		Screen.DrawText(mBigFont,Font.CR_RED,xx,yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alph,DTA_ScaleX,4,DTA_ScaleY,4);
		if ( demo.restimer > 0 ) return (1.-dimalph);	// don't draw prompts while reviving
		if ( multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn) )
		{
			if ( sv_norespawn ) return (1.-dimalph);
			alph = clamp((deadtimer-90)/60.,0.,1.);
			str = String.Format(StringTable.Localize("$SWWM_URDEDMP"));
			len = mSmallFont.StringWidth(str);
			xx = int((ss.x-len)/2.);
			yy = ss.y/2.;
			Screen.DrawText(mSmallFont,Font.CR_WHITE,xx,yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alph);
			return (1.-dimalph);
		}
		alph = clamp((deadtimer-140)/60.,0.,1.);
		if ( demo.restype == SWWMPlayer.RT_REVIVE ) str = String.Format(StringTable.Localize("$SWWM_URDED2"));
		else if ( demo.restype == SWWMPlayer.RT_RESPAWN ) str = String.Format(StringTable.Localize("$SWWM_URDED3"));
		else str = String.Format(StringTable.Localize("$SWWM_URDED4"));
		len = mSmallFont.StringWidth(str);
		xx = int((ss.x-len)/2.);
		yy = ss.y/2.;
		Screen.DrawText(mSmallFont,Font.CR_WHITE,xx,yy,str,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_Alpha,alph);
		return (1.-dimalph);
	}

	override void Draw( int state, double TicFrac )
	{
		Super.Draw(state,TicFrac);
		int CurFrame = MSTime();
		FrameTime = (CurFrame-PrevFrame)/1000.;
		if ( (state != HUD_StatusBar) && (state != HUD_Fullscreen) )
		{
			PrevFrame = CurFrame;
			return;
		}
		if ( !hnd ) hnd = SWWMHandler(EventHandler.Find("SWWMHandler"));
		if ( !(players[consoleplayer].Camera is 'PlayerPawn') ) camhidden = true;
		else camhidden = false;
		BeginHUD();
		if ( swwm_hudscale ) hs = CleanXFac_1;
		else hs = max(floor(Screen.GetWidth()/640.),1.);
		ss = (Screen.GetWidth(),Screen.GetHeight())/hs;
		margin = clamp(swwm_hudmargin,0,40);
		FracTic = TicFrac;
		if ( camhidden )
		{
			DrawPickups();
			DrawDeath();
			DrawMessages(0.);
		}
		else
		{
			DrawTarget();
			DrawTopStuff();
			int invy = DrawStatus();
			DrawInventory(invy);
			DrawWeapons();
			DrawPickups();
			double malph = DrawDeath();
			DrawMessages(malph);
		}
		PrevFrame = CurFrame;
	}
}
